[{"content":"ğŸ” What is the Semantic Kernel Agentic Framework? Microsoft\u0026rsquo;s Semantic Kernel is an open-source SDK designed to simplify integrating AI into your applications. The Agentic Framework within Semantic Kernel helps you build intelligent, task-driven agents that:\nAutonomously plan and execute tasks Use plugins (functionality modules) Interact via AI services (like OpenAI or Azure OpenAI) Maintain conversation context The agents are powered by LLMs and enriched through planning, memory, function calling, and more.\nğŸ› ï¸ Prerequisites To get started, ensure you have:\n.NET 8 SDK Visual Studio Code or Visual Studio OpenAI or Azure OpenAI API keys Basic knowledge of C# Install the core Semantic Kernel SDK:\n1 2 dotnet add package Microsoft.SemanticKernel dotnet add package Microsoft.SemanticKernel.Agents.OpenAI ğŸ§± Architecture Overview At its core, an AI agent in Semantic Kernel involves:\nKernel â€“ The runtime for all services and plugins. Plugins â€“ Reusable sets of functions exposed to the LLM. Agent â€“ A class implementing IAgent, capable of interacting via ReceiveAsync. Planner (Optional) â€“ For complex, multi-step goals. Chat Completion â€“ Connects to an LLM (e.g., GPT-4). ğŸš€ Step-by-Step: Building an Agent 1. ğŸ”Œ Define a Plugin 1 2 3 4 5 6 7 8 9 10 11 12 using Microsoft.SemanticKernel; using System.ComponentModel; public class WeatherPlugin { [KernelFunction(\u0026#34;get_weather\u0026#34;)] [Description(\u0026#34;Gets today\u0026#39;s weather for a specific city.\u0026#34;)] public string GetWeather(string city) { return $\u0026#34;The weather in {city} is sunny and 25Â°C.\u0026#34;; } } 2. ğŸ§  Set Up the Kernel 1 2 3 4 5 6 7 8 9 10 11 12 13 using Microsoft.SemanticKernel; using Microsoft.SemanticKernel.ChatCompletion; using Microsoft.SemanticKernel.Connectors.OpenAI; using Microsoft.Extensions.Logging; var builder = Kernel.CreateBuilder(); builder.AddOpenAIChatCompletion(\u0026#34;gpt-4\u0026#34;, \u0026#34;\u0026lt;your-api-key\u0026gt;\u0026#34;); // Or AzureOpenAI builder.Plugins.AddFromType\u0026lt;WeatherPlugin\u0026gt;(); builder.Services.AddLogging(logging =\u0026gt; logging.AddConsole().SetMinimumLevel(LogLevel.Information)); var kernel = builder.Build(); 3. ğŸ¤– Create a Custom Agent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using Microsoft.SemanticKernel.Agents; using Microsoft.SemanticKernel.ChatCompletion; public class WeatherAgent : IAgent { public string Name =\u0026gt; \u0026#34;Weather Agent\u0026#34;; public string Description =\u0026gt; \u0026#34;I can tell you the weather for any city.\u0026#34;; private readonly Kernel _kernel; private readonly IChatCompletionService _chat; public WeatherAgent(Kernel kernel) { _kernel = kernel; _chat = kernel.GetRequiredService\u0026lt;IChatCompletionService\u0026gt;(); } public async Task\u0026lt;AgentThought\u0026gt; ReceiveAsync(AgentThought input, Kernel kernel, CancellationToken cancellationToken = default) { var history = new ChatHistory(); history.AddUserMessage(input.Input); var response = await _chat.GetChatMessageContentAsync(history, kernel: _kernel, cancellationToken: cancellationToken); return new AgentThought(response?.Content ?? \u0026#34;I\u0026#39;m not sure.\u0026#34;); } } 4. ğŸšª Run the Agent 1 2 3 4 5 var agent = new WeatherAgent(kernel); var input = new AgentThought(\u0026#34;What\u0026#39;s the weather like in Delhi?\u0026#34;); var response = await agent.ReceiveAsync(input, kernel); Console.WriteLine($\u0026#34;ğŸ¤– Agent: {response.Input}\u0026#34;); ğŸ§  What Just Happened? You registered a plugin (WeatherPlugin) with a function the model can call. Created an Agent class (WeatherAgent) that wraps the kernel. Sent a message (AgentThought) to the agent, who routed it through the kernel and got a response from the LLM. The model auto-selected get_weather and generated a meaningful reply. ğŸ“ Optional: Enable Planning Want your agent to plan steps before answering?\nAdd the planner using:\n1 dotnet add package Microsoft.SemanticKernel.Planning.Handlebars Configure like this:\n1 2 3 4 5 6 using Microsoft.SemanticKernel.Planning.Handlebars; var planner = new HandlebarsPlanner(kernel); var plan = await planner.CreatePlanAsync(\u0026#34;Tell me the weather and suggest an outfit.\u0026#34;); await plan.InvokeAsync(kernel); ğŸ” Best Practices Keep plugin methods descriptive with [Description] for better LLM comprehension. Limit token size in plugins to avoid context overflow. Use FunctionChoiceBehavior.Auto() to let LLM decide what to call. Add filters or logging for observability. ğŸ“š Conclusion The Agentic Framework in Semantic Kernel brings powerful abstractions for building AI-native applications. You can create rich AI agents capable of decision-making, task execution, and integrating into real-world systems.\nWhether you\u0026rsquo;re building a chatbot, automation tool, or an autonomous assistant â€” Semantic Kernel provides all the primitives you need.\n","date":"2025-05-03T15:58:12+05:30","image":"https://thecodestreet.dev/post/how-to-create-ai-agents-using-semantic-kernels-agentic-framework/TheCodeStreet%20Website%20-%20AI%20Agents_hu_4abfbc08c8332102.webp","permalink":"https://thecodestreet.dev/post/how-to-create-ai-agents-using-semantic-kernels-agentic-framework/","title":"How to Create AI Agents Using Semantic Kernelâ€™s Agentic Framework"},{"content":"ğŸ” What is Semantic Kernel? Semantic Kernel is an open-source SDK developed by Microsoft that lets you infuse AI capabilities (like OpenAI, Azure OpenAI, HuggingFace) into your apps by:\nâœ… Integrating LLMs (e.g., GPT-4) âœ… Creating modular AI plugins (called functions) âœ… Enabling function calling, planners, memory, and agents âœ… Supporting multimodal workflows (text, embeddings, images)\nğŸ§¹ Key Features Kernel: The brain that coordinates AI calls, plugins, memory, and more Plugins: Reusable functions exposed to the LLM Planners: Converts goals into multi-step plans using AI Memory: Store and recall past interactions (long-term memory) Agents: Autonomously act using LLMs, context, and function calls Connectors: Native integration with OpenAI, Azure OpenAI, HuggingFace, and more ğŸ› ï¸ Supported Languages C# (.NET 8) â€“ Most mature implementation Python Java â€“ (Experimental) âš™ï¸ How It Works â€“ Simplified Flow 1 2 3 4 5 6 7 graph TD; UserInput --\u0026gt; Kernel; Kernel --\u0026gt; PluginFunctions; Kernel --\u0026gt; ChatCompletion; Kernel --\u0026gt; Planner; ChatCompletion --\u0026gt; LLM(OpenAI / Azure OpenAI); Kernel --\u0026gt; Response; You send a prompt like â€œSend a thank-you emailâ€ The Kernel evaluates context and finds matching plugin functions It uses the LLM to execute or plan steps The response is returned with reasoning and actions ğŸš€ Best Use Cases for Semantic Kernel 1. ğŸš£ï¸ Conversational AI Agents Create chatbots, support agents, or assistants that:\nCall plugins (e.g., check weather, send emails) Maintain memory Autonomously plan steps Route between plugins and LLM ğŸ§  Example: A personal assistant that manages your calendar, files, and emails through voice/text.\n2. ğŸ“„ Automated Document Processing Use Semantic Kernel for:\nSummarizing reports Extracting data (names, dates, entities) Structuring unstructured PDFs/emails ğŸ§  Example: A tool that processes resumes and classifies them by skills.\n3. âœ¨ AI Copilots for Internal Tools Embed AI in:\nCRM ERP dashboards Code documentation systems SK plugins can wrap your APIs or business logic, and allow the LLM to smartly route queries.\nğŸ§  Example: â€œWhat were our top 3 deals last quarter?â€ â†’ Plugin calls CRM API â†’ returns answer.\n4. ğŸ§  Knowledge Retrieval Systems (RAG) Use embeddings + vector databases to:\nSearch across documents or knowledge bases Add long-term memory Retrieve relevant info before LLM answers ğŸ§  Example: Ask questions to a 10,000-page PDF repository in natural language.\n5. ğŸ¤– Autonomous Multi-Agent Systems Coordinate agents that:\nHave their own memory and personality Collaborate through messages Solve tasks in parallel ğŸ§  Example: A research agent, writer agent, and SEO agent that together generate and publish a blog post.\nğŸ§  Why Choose Semantic Kernel? Feature Semantic Kernel LangChain LlamaIndex .NET Support âœ… Best-in-class âŒ âŒ Function Calling âœ… Plugins via attributes âœ… âŒ Native Planner âœ… Handlebars Planner âš ï¸ âš ï¸ Agentic Framework âœ… Built-in âš ï¸ Basic âš ï¸ Experimental Open Source âœ… MIT License âœ… âœ… ğŸ“¦ Sample Plugin Code (C#) 1 2 3 4 5 6 public class MathPlugin { [KernelFunction(\u0026#34;add\u0026#34;)] [Description(\u0026#34;Adds two numbers.\u0026#34;)] public int Add(int a, int b) =\u0026gt; a + b; } The LLM can automatically invoke this when you say: â€œWhat\u0026rsquo;s 5 plus 7?â€\nğŸ“˜ Conclusion Microsoft Semantic Kernel is not just a wrapper around LLMs. Itâ€™s a composable framework for building intelligent, context-aware, and action-driven applications.\nWhether you\u0026rsquo;re automating internal tools, building agents, or enabling AI-first product experiencesâ€”SK gives you the modularity and power needed.\n","date":"2025-05-03T15:58:12+05:30","image":"https://thecodestreet.dev/post/what-is-semantic-kernel-best-use-cases-for-building-ai-first-apps-with-microsofts-open-source-sdk/TheCodeStreet%20-%20Thumbnail_hu_8e3d22f8d801e43f.webp","permalink":"https://thecodestreet.dev/post/what-is-semantic-kernel-best-use-cases-for-building-ai-first-apps-with-microsofts-open-source-sdk/","title":"What is Semantic Kernel? Best Use Cases for Building AI-First Apps with Microsoftâ€™s Open-Source SDK"},{"content":"ğŸ§  What is the Process Framework in Semantic Kernel? The Process Framework in Semantic Kernel is a high-level orchestration layer that allows developers to define complex AI-driven processes as reusable workflows.\nThese processes can:\nInvolve multiple steps or phases Utilize plugins, agents, prompts, or planners Support stateful execution and decision logic Think of it as an AI-native state machine that defines what should happen, when, and how.\nExample: You can define a process like Onboard New Employee which involves gathering details, generating a welcome email, and scheduling orientation meetings â€” all coordinated by the kernel.\nğŸš€ Why Use the Process Framework? Using the Process Framework gives your AI app superpowers like:\nâœ… Repeatable AI Workflows Define repeatable, human-like processes that AI can follow every time a task is triggered.\nâœ… Declarative Structure Design your logic in YAML or C#â€”easy to maintain, version, and update.\nâœ… Plugin \u0026amp; Planner Integration Let AI choose when to use a plugin vs. LLM generation vs. planner to solve problems.\nâœ… Dynamic Decision Making Incorporate logic, memory, or prompts dynamically based on context or conditions.\nğŸ“¦ Common Use Cases 1. ğŸ§‘â€ğŸ’¼ Employee Onboarding Automation Collect user data Generate personalized emails Create calendar invites Notify HR 2. âœ¨ Blog Generation Pipeline Research keyword Generate blog outline Write content with SEO focus Publish to CMS 3. ğŸ“„ Document Review Workflow Analyze uploaded doc Extract key points Flag action items Notify reviewers ğŸ› ï¸ Example: YAML-Based Process Definition Hereâ€™s a simplified YAML-style structure:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 steps: - name: collect_input type: prompt template: \u0026#34;Ask user for project details\u0026#34; - name: generate_summary type: plugin plugin_name: TextSummaryPlugin function: summarize - name: send_email type: plugin plugin_name: EmailPlugin function: send_email This defines a flow where:\nAI collects input from the user Uses a plugin to summarize Sends it using another plugin ğŸ” Best Practices âœ³ï¸ Start simple: Begin with 2-3 step processes before scaling ğŸ” Design for reusability: Make steps generic so they work across scenarios ğŸ§© Use plugins smartly: Use them to avoid LLM hallucinations on predictable logic ğŸ§  Add memory: Maintain context between steps with long-term memory ğŸ§  Final Thoughts The Process Framework in Semantic Kernel helps developers codify AI behavior with precision, logic, and reuse. It enables building structured flows instead of just ad-hoc prompt chains â€” making your AI systems smarter, more maintainable, and enterprise-ready.\nWhether youâ€™re building internal tools, chatbots, document processors, or content pipelines â€” Semantic Kernel\u0026rsquo;s Process Framework brings powerful orchestration to your AI toolkit.\n","date":"2025-05-03T15:58:12+05:30","image":"https://thecodestreet.dev/post/what-is-the-process-framework-in-semantic-kernel-and-how-it-helps-ai-app-development/TheCodeStreet%20-%20Process%20Framework_hu_6cfee30df2e3e2d8.webp","permalink":"https://thecodestreet.dev/post/what-is-the-process-framework-in-semantic-kernel-and-how-it-helps-ai-app-development/","title":"What is the Process Framework in Semantic Kernel and How It Helps AI App Development"},{"content":"ğŸ” What Are Plugins in Semantic Kernel? Semantic Kernel plugins are classes that expose one or more methods (functions) that Large Language Models (LLMs) like GPT-4 can call when processing user prompts. These functions are designed to:\nPerform specific business logic Interact with your appâ€™s data or services Execute commands in a controlled and modular way Plugins are tagged with [KernelFunction] and [Description] attributes, making them discoverable and explainable to the LLM.\nğŸš€ Why Should You Use Semantic Kernel Plugins? Semantic Kernel plugins help you build modular, secure, and reusable components that can be invoked dynamically by LLMs based on user input.\nâœ… Benefits of Using Plugins Modularity: Cleanly separate logic for easy reuse Security: Control exactly which actions the LLM can perform Discoverability: Enable function calling with semantic understanding Flexibility: Use in agents, planners, chat apps, copilots, etc. This makes them perfect for AI copilots, automation bots, and intelligent workflows.\nğŸ› ï¸ Step-by-Step Plugin Implementation in C# Step 1: Define a Plugin Class 1 2 3 4 5 6 7 8 9 10 11 12 13 using Microsoft.SemanticKernel; using System.ComponentModel; public class UtilityPlugin { [KernelFunction(\u0026#34;get_time\u0026#34;)] [Description(\u0026#34;Returns the current system time in 24-hour format.\u0026#34;)] public string GetTime() =\u0026gt; DateTime.Now.ToString(\u0026#34;HH:mm\u0026#34;); [KernelFunction(\u0026#34;add_numbers\u0026#34;)] [Description(\u0026#34;Adds two integers and returns the result.\u0026#34;)] public int Add(int a, int b) =\u0026gt; a + b; } Step 2: Register the Plugin with the Kernel 1 2 3 4 5 6 var builder = Kernel.CreateBuilder(); builder.AddOpenAIChatCompletion(\u0026#34;gpt-4\u0026#34;, \u0026#34;\u0026lt;api-key\u0026gt;\u0026#34;); builder.Plugins.AddFromType\u0026lt;UtilityPlugin\u0026gt;(); var kernel = builder.Build(); Step 3: Invoke the Plugin via Prompt 1 2 3 var prompt = \u0026#34;What time is it right now?\u0026#34;; var result = await kernel.InvokePromptAsync(prompt); Console.WriteLine(result.GetValue\u0026lt;string\u0026gt;()); The LLM recognizes the intent behind the question and uses the get_time plugin function automatically.\nğŸ’¡ Real-World Examples of Semantic Kernel Plugins ğŸ“¬ Email Sender Plugin 1 2 3 4 5 6 7 8 9 10 public class EmailPlugin { [KernelFunction(\u0026#34;send_email\u0026#34;)] [Description(\u0026#34;Sends an email with the provided subject and message.\u0026#34;)] public string SendEmail(string to, string subject, string message) { // Logic to send email return $\u0026#34;Email sent to {to} with subject \u0026#39;{subject}\u0026#39;.\u0026#34;; } } ğŸ“† Calendar Plugin 1 2 3 4 5 6 7 8 9 public class CalendarPlugin { [KernelFunction(\u0026#34;schedule_meeting\u0026#34;)] [Description(\u0026#34;Schedules a meeting at a specified time.\u0026#34;)] public string Schedule(string title, string time) { return $\u0026#34;Meeting \u0026#39;{title}\u0026#39; scheduled for {time}.\u0026#34;; } } These plugins empower the LLM to respond to prompts like:\nâ€œSend an update email to Sarah about the project status.â€ â€œSchedule a 3 PM team sync on Friday.â€ ğŸ” Best Practices for Plugin Design ğŸ§© One function = one responsibility ğŸ“ Add clear [Description] for each function ğŸš« Avoid exposing unsafe or sensitive logic ğŸ§ª Keep plugins unit-testable ğŸ§  Prefer small, composable functions over large ones ğŸ§  Final Thoughts If you\u0026rsquo;re developing AI-powered apps using Microsoft Semantic Kernel, plugins are your interface between GPT and the real world. Whether you want to automate calendars, fetch data, send messages, or control devices â€” plugins provide the control and structure needed for safe and scalable AI workflows.\n","date":"2025-05-02T15:58:12+05:30","image":"https://thecodestreet.dev/post/semantic-kernel-plugins-explained-boost-your-ai-app-development-with-modular-functionality/TheCodeStreet%20-%20Plugins_hu_51a179a59b074fc5.webp","permalink":"https://thecodestreet.dev/post/semantic-kernel-plugins-explained-boost-your-ai-app-development-with-modular-functionality/","title":"Semantic Kernel Plugins Explained: Boost Your AI App Development with Modular Functionality"}]